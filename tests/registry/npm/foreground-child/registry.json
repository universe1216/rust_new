{"name":"foreground-child","description":"Run a child as if it's the foreground process. Give it stdio. Exit when it exits.","dist-tags":{"latest":"3.2.1"},"versions":{"3.2.1":{"name":"foreground-child","version":"3.2.1","description":"Run a child as if it's the foreground process. Give it stdio. Exit when it exits.","main":"./dist/commonjs/index.js","types":"./dist/commonjs/index.d.ts","exports":{"./watchdog":{"import":{"source":"./src/watchdog.ts","types":"./dist/esm/watchdog.d.ts","default":"./dist/esm/watchdog.js"},"require":{"source":"./src/watchdog.ts","types":"./dist/commonjs/watchdog.d.ts","default":"./dist/commonjs/watchdog.js"}},"./proxy-signals":{"import":{"source":"./src/proxy-signals.ts","types":"./dist/esm/proxy-signals.d.ts","default":"./dist/esm/proxy-signals.js"},"require":{"source":"./src/proxy-signals.ts","types":"./dist/commonjs/proxy-signals.d.ts","default":"./dist/commonjs/proxy-signals.js"}},"./package.json":"./package.json",".":{"import":{"source":"./src/index.ts","types":"./dist/esm/index.d.ts","default":"./dist/esm/index.js"},"require":{"source":"./src/index.ts","types":"./dist/commonjs/index.d.ts","default":"./dist/commonjs/index.js"}}},"engines":{"node":">=14"},"dependencies":{"cross-spawn":"^7.0.0","signal-exit":"^4.0.1"},"scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","prepare":"tshy","pretest":"npm run prepare","presnap":"npm run prepare","test":"tap","snap":"tap","format":"prettier --write . --log-level warn","typedoc":"typedoc --tsconfig .tshy/esm.json ./src/*.ts"},"prettier":{"experimentalTernaries":true,"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"typecheck":true},"repository":{"type":"git","url":"git+https://github.com/tapjs/foreground-child.git"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"ISC","devDependencies":{"@types/cross-spawn":"^6.0.2","@types/node":"^18.15.11","@types/tap":"^15.0.8","prettier":"^3.3.2","tap":"^19.2.5","tshy":"^1.15.1","typedoc":"^0.24.2","typescript":"^5.0.2"},"funding":{"url":"https://github.com/sponsors/isaacs"},"tshy":{"exports":{"./watchdog":"./src/watchdog.ts","./proxy-signals":"./src/proxy-signals.ts","./package.json":"./package.json",".":"./src/index.ts"}},"type":"module","_id":"foreground-child@3.2.1","gitHead":"132a0178990aa4f53a6208bc3bdb90369b35e434","bugs":{"url":"https://github.com/tapjs/foreground-child/issues"},"_nodeVersion":"20.13.1","_npmVersion":"10.7.0","dist":{"integrity":"sha512-PXUUyLqrR2XCWICfv6ukppP96sdFwWbNEnfEMt7jNsISjMsvaLNinAHNDYyvkyU+SZG2BTSbT5NjG+vZslfGTA==","shasum":"767004ccf3a5b30df39bed90718bab43fe0a59f7","tarball":"http://localhost:4260/foreground-child/foreground-child-3.2.1.tgz","fileCount":37,"unpackedSize":68184,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICh3UF+VAJBE3PR4nCLEMutI04CojoFdJIieW6ffZVutAiBpPfgu74fUsaEfaA39HHpkoMqf9ICY3vOGIdNkiz3TWw=="}]},"directories":{},"_hasShrinkwrap":false}},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/tapjs/foreground-child.git"},"license":"ISC","homepage":"https://github.com/tapjs/foreground-child#readme","bugs":{"url":"https://github.com/tapjs/foreground-child/issues"},"readme":"# foreground-child\n\nRun a child as if it's the foreground process. Give it stdio. Exit\nwhen it exits.\n\nMostly this module is here to support some use cases around\nwrapping child processes for test coverage and such. But it's\nalso generally useful any time you want one program to execute\nanother as if it's the \"main\" process, for example, if a program\ntakes a `--cmd` argument to execute in some way.\n\n## USAGE\n\n```js\nimport { foregroundChild } from 'foreground-child'\n// hybrid module, this also works:\n// const { foregroundChild } = require('foreground-child')\n\n// cats out this file\nconst child = foregroundChild('cat', [__filename])\n\n// At this point, it's best to just do nothing else.\n// return or whatever.\n// If the child gets a signal, or just exits, then this\n// parent process will exit in the same way.\n```\n\nYou can provide custom spawn options by passing an object after\nthe program and arguments:\n\n```js\nconst child = foregroundChild(`cat ${__filename}`, { shell: true })\n```\n\nA callback can optionally be provided, if you want to perform an\naction before your foreground-child exits:\n\n```js\nconst child = foregroundChild('cat', [__filename], spawnOptions, () => {\n  doSomeActions()\n})\n```\n\nThe callback can return a Promise in order to perform\nasynchronous actions. If the callback does not return a promise,\nthen it must complete its actions within a single JavaScript\ntick.\n\n```js\nconst child = foregroundChild('cat', [__filename], async () => {\n  await doSomeAsyncActions()\n})\n```\n\nIf the callback throws or rejects, then it will be unhandled, and\nnode will exit in error.\n\nIf the callback returns a string value, then that will be used as\nthe signal to exit the parent process. If it returns a number,\nthen that number will be used as the parent exit status code. If\nit returns boolean `false`, then the parent process will not be\nterminated. If it returns `undefined`, then it will exit with the\nsame signal/code as the child process.\n\n## Caveats\n\nThe \"normal\" standard IO file descriptors (0, 1, and 2 for stdin,\nstdout, and stderr respectively) are shared with the child process.\nAdditionally, if there is an IPC channel set up in the parent, then\nmessages are proxied to the child on file descriptor 3.\n\nIn Node, it's possible to also map arbitrary file descriptors\ninto a child process. In these cases, foreground-child will not\nmap the file descriptors into the child. If file descriptors 0,\n1, or 2 are used for the IPC channel, then strange behavior may\nhappen (like printing IPC messages to stderr, for example).\n\nNote that a SIGKILL will always kill the parent process, but\nwill not proxy the signal to the child process, because SIGKILL\ncannot be caught. In order to address this, a special \"watchdog\"\nchild process is spawned which will send a SIGKILL to the child\nprocess if it does not terminate within half a second after the\nwatchdog receives a SIGHUP due to its parent terminating.\n\nOn Windows, issuing a `process.kill(process.pid, signal)` with a\nfatal termination signal may cause the process to exit with a `1`\nstatus code rather than reporting the signal properly. This\nmodule tries to do the right thing, but on Windows systems, you\nmay see that incorrect result. There is as far as I'm aware no\nworkaround for this.\n\n## util: `foreground-child/proxy-signals`\n\nIf you just want to proxy the signals to a child process that the\nmain process receives, you can use the `proxy-signals` export\nfrom this package.\n\n```js\nimport { proxySignals } from 'foreground-child/proxy-signals'\n\nconst childProcess = spawn('command', ['some', 'args'])\nproxySignals(childProcess)\n```\n\nNow, any fatal signal received by the current process will be\nproxied to the child process.\n\nIt doesn't go in the other direction; ie, signals sent to the\nchild process will not affect the parent. For that, listen to the\nchild `exit` or `close` events, and handle them appropriately.\n\n## util: `foreground-child/watchdog`\n\nIf you are spawning a child process, and want to ensure that it\nisn't left dangling if the parent process exits, you can use the\nwatchdog utility exported by this module.\n\n```js\nimport { watchdog } from 'foreground-child/watchdog'\n\nconst childProcess = spawn('command', ['some', 'args'])\nconst watchdogProcess = watchdog(childProcess)\n\n// watchdogProcess is a reference to the process monitoring the\n// parent and child. There's usually no reason to do anything\n// with it, as it's silent and will terminate\n// automatically when it's no longer needed.\n```\n","readmeFilename":"README.md"}

{"name":"jackspeak","dist-tags":{"latest":"3.4.2"},"versions":{"3.4.2":{"name":"jackspeak","version":"3.4.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"license":"BlueOak-1.0.0","_id":"jackspeak@3.4.2","bugs":{"url":"https://github.com/isaacs/jackspeak/issues"},"dist":{"shasum":"c3d1e00071d52dba8b0dac17cd2a12d0187d2989","tarball":"http://localhost:4260/jackspeak/jackspeak-3.4.2.tgz","fileCount":21,"integrity":"sha512-qH3nOSj8q/8+Eg8LUPOq3C+6HWkpUioIjDsq1+D4zY91oZvpPttw8GwtF1nReRYKXl+1AORyFqtm2f5Q1SB6/Q==","signatures":[{"sig":"MEYCIQDQjdGlw/fkPqtOMv0ucXnRk/TkZ7m8bjI2nqJOW+BxKwIhAPHs+uDvbBHMqu25nIadbvcYqmBpXJoGiC6V3SFfUxkl","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":297035},"main":"./dist/commonjs/index.js","tshy":{"main":true,"exports":{".":"./src/index.js","./package.json":"./package.json"}},"type":"module","types":"./dist/commonjs/index.d.ts","engines":{"node":"14 >=14.21 || 16 >=16.20 || >=18"},"exports":{".":{"import":{"types":"./dist/esm/index.d.ts","default":"./dist/esm/index.js"},"require":{"types":"./dist/commonjs/index.d.ts","default":"./dist/commonjs/index.js"}},"./package.json":"./package.json"},"funding":{"url":"https://github.com/sponsors/isaacs"},"gitHead":"82d3614e0715078b922819785abd1e534121b51c","scripts":{"snap":"tap","test":"tap","format":"prettier --write . --log-level warn","prepare":"tshy","presnap":"npm run prepare","pretest":"npm run prepare","typedoc":"typedoc --tsconfig .tshy/esm.json ./src/*.ts","preversion":"npm test","postversion":"npm publish","build-examples":"for i in examples/*.js ; do node $i -h > ${i/.js/.txt}; done","prepublishOnly":"git push origin --follow-tags"},"prettier":{"semi":false,"useTabs":false,"tabWidth":2,"endOfLine":"lf","printWidth":75,"arrowParens":"avoid","singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"experimentalTernaries":true},"repository":{"url":"git+https://github.com/isaacs/jackspeak.git","type":"git"},"_npmVersion":"10.7.0","description":"A very strict and proper argument parser.","directories":{},"_nodeVersion":"20.13.1","dependencies":{"@isaacs/cliui":"^8.0.2"},"_hasShrinkwrap":false,"devDependencies":{"tap":"^18.8.0","tshy":"^1.14.0","typedoc":"^0.25.1","prettier":"^3.2.5","typescript":"^5.2.2","@types/node":"^20.7.0","@types/pkgjs__parseargs":"^0.10.1"},"optionalDependencies":{"@pkgjs/parseargs":"^0.11.0"}}},"bugs":{"url":"https://github.com/isaacs/jackspeak/issues"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"license":"BlueOak-1.0.0","homepage":"https://github.com/isaacs/jackspeak#readme","repository":{"type":"git","url":"git+https://github.com/isaacs/jackspeak.git"},"description":"A very strict and proper argument parser.","readme":"# jackspeak\n\nA very strict and proper argument parser.\n\nValidate string, boolean, and number options, from the command\nline and the environment.\n\nCall the `jack` method with a config object, and then chain\nmethods off of it.\n\nAt the end, call the `.parse()` method, and you'll get an object\nwith `positionals` and `values` members.\n\nAny unrecognized configs or invalid values will throw an error.\n\nAs long as you define configs using object literals, types will\nbe properly inferred and TypeScript will know what kinds of\nthings you got.\n\nIf you give it a prefix for environment variables, then defaults\nwill be read from the environment, and parsed values written back\nto it, so you can easily pass configs through to child processes.\n\nAutomatically generates a `usage`/`help` banner by calling the\n`.usage()` method.\n\nUnless otherwise noted, all methods return the object itself.\n\n## USAGE\n\n```js\nimport { jack } from 'jackspeak'\n// this works too:\n// const { jack } = require('jackspeak')\n\nconst { positionals, values } = jack({ envPrefix: 'FOO' })\n  .flag({\n    asdf: { description: 'sets the asfd flag', short: 'a', default: true },\n    'no-asdf': { description: 'unsets the asdf flag', short: 'A' },\n    foo: { description: 'another boolean', short: 'f' },\n  })\n  .optList({\n    'ip-addrs': {\n      description: 'addresses to ip things',\n      delim: ',', // defaults to '\\n'\n      default: ['127.0.0.1'],\n    },\n  })\n  .parse([\n    'some',\n    'positional',\n    '--ip-addrs',\n    '192.168.0.1',\n    '--ip-addrs',\n    '1.1.1.1',\n    'args',\n    '--foo', // sets the foo flag\n    '-A', // short for --no-asdf, sets asdf flag to false\n  ])\n\nconsole.log(process.env.FOO_ASDF) // '0'\nconsole.log(process.env.FOO_FOO) // '1'\nconsole.log(values) // {\n//   'ip-addrs': ['192.168.0.1', '1.1.1.1'],\n//   foo: true,\n//   asdf: false,\n// }\nconsole.log(process.env.FOO_IP_ADDRS) // '192.168.0.1,1.1.1.1'\nconsole.log(positionals) // ['some', 'positional', 'args']\n```\n\n## `jack(options: JackOptions = {}) => Jack`\n\nReturns a `Jack` object that can be used to chain and add\nfield definitions. The other methods (apart from `validate()`,\n`parse()`, and `usage()` obviously) return the same Jack object,\nupdated with the new types, so they can be chained together as\nshown in the code examples.\n\nOptions:\n\n- `allowPositionals` Defaults to true. Set to `false` to not\n  allow any positional arguments.\n\n- `envPrefix` Set to a string to write configs to and read\n  configs from the environment. For example, if set to `MY_APP`\n  then the `foo-bar` config will default based on the value of\n  `env.MY_APP_FOO_BAR` and will write back to that when parsed.\n\n  Boolean values are written as `'1'` and `'0'`, and will be\n  treated as `true` if they're `'1'` or false otherwise.\n\n  Number values are written with their `toString()`\n  representation.\n\n  Strings are just strings.\n\n  Any value with `multiple: true` will be represented in the\n  environment split by a delimiter, which defaults to `\\n`.\n\n- `env` The place to read/write environment variables. Defaults\n  to `process.env`.\n\n- `usage` A short usage string to print at the top of the help\n  banner.\n\n- `stopAtPositional` Boolean, default false. Stop parsing opts\n  and flags at the first positional argument. This is useful if\n  you want to pass certain options to subcommands, like some\n  programs do, so you can stop parsing and pass the positionals\n  to the subcommand to parse.\n\n- `stopAtPositionalTest` Conditional `stopAtPositional`. Provide\n  a function that takes a positional argument string and returns\n  boolean. If it returns `true`, then parsing will stop. Useful\n  when _some_ subcommands should parse the rest of the command\n  line options, and others should not.\n\n### `Jack.heading(text: string, level?: 1 | 2 | 3 | 4 | 5 | 6)`\n\nDefine a short string heading, used in the `usage()` output.\n\nIndentation of the heading and subsequent description/config\nusage entries (up until the next heading) is set by the heading\nlevel.\n\nIf the first usage item defined is a heading, it is always\ntreated as level 1, regardless of the argument provided.\n\nHeadings level 1 and 2 will have a line of padding underneath\nthem. Headings level 3 through 6 will not.\n\n### `Jack.description(text: string, { pre?: boolean } = {})`\n\nDefine a long string description, used in the `usage()` output.\n\nIf the `pre` option is set to `true`, then whitespace will not be\nnormalized. However, if any line is too long for the width\nallotted, it will still be wrapped.\n\n## Option Definitions\n\nConfigs are defined by calling the appropriate field definition\nmethod with an object where the keys are the long option name,\nand the value defines the config.\n\nOptions:\n\n- `type` Only needed for the `addFields` method, as the others\n  set it implicitly. Can be `'string'`, `'boolean'`, or\n  `'number'`.\n- `multiple` Only needed for the `addFields` method, as the\n  others set it implicitly. Set to `true` to define an array\n  type. This means that it can be set on the CLI multiple times,\n  set as an array in the `values`\n  and it is represented in the environment as a delimited string.\n- `short` A one-character shorthand for the option.\n- `description` Some words to describe what this option is and\n  why you'd set it.\n- `hint` (Only relevant for non-boolean types) The thing to show\n  in the usage output, like `--option=<hint>`\n- `validate` A function that returns false (or throws) if an\n  option value is invalid.\n- `validOptions` An array of strings or numbers that define the\n  valid values that can be set. This is not allowed on `boolean`\n  (flag) options. May be used along with a `validate()` method.\n- `default` A default value for the field. Note that this may be\n  overridden by an environment variable, if present.\n\n### `Jack.flag({ [option: string]: definition, ... })`\n\nDefine one or more boolean fields.\n\nBoolean options may be set to `false` by using a\n`--no-${optionName}` argument, which will be implicitly created\nif it's not defined to be something else.\n\nIf a boolean option named `no-${optionName}` with the same\n`multiple` setting is in the configuration, then that will be\ntreated as a negating flag.\n\n### `Jack.flagList({ [option: string]: definition, ... })`\n\nDefine one or more boolean array fields.\n\n### `Jack.num({ [option: string]: definition, ... })`\n\nDefine one or more number fields. These will be set in the\nenvironment as a stringified number, and included in the `values`\nobject as a number.\n\n### `Jack.numList({ [option: string]: definition, ... })`\n\nDefine one or more number list fields. These will be set in the\nenvironment as a delimited set of stringified numbers, and\nincluded in the `values` as a number array.\n\n### `Jack.opt({ [option: string]: definition, ... })`\n\nDefine one or more string option fields.\n\n### `Jack.optList({ [option: string]: definition, ... })`\n\nDefine one or more string list fields.\n\n### `Jack.addFields({ [option: string]: definition, ... })`\n\nDefine one or more fields of any type. Note that `type` and\n`multiple` must be set explicitly on each definition when using\nthis method.\n\n## Actions\n\nUse these methods on a Jack object that's already had its config\nfields defined.\n\n### `Jack.parse(args: string[] = process.argv): { positionals: string[], values: OptionsResults }`\n\nParse the arguments list, write to the environment if `envPrefix`\nis set, and returned the parsed values and remaining positional\narguments.\n\n### `Jack.validate(o: any): asserts o is OptionsResults`\n\nThrows an error if the object provided is not a valid result set,\nfor the configurations defined thusfar.\n\n### `Jack.usage(): string`\n\nReturns the compiled `usage` string, with all option descriptions\nand heading/description text, wrapped to the appropriate width\nfor the terminal.\n\n### `Jack.setConfigValues(options: OptionsResults, src?: string)`\n\nValidate the `options` argument, and set the default value for\neach field that appears in the options.\n\nValues provided will be overridden by environment variables or\ncommand line arguments.\n\n### `Jack.usageMarkdown(): string`\n\nReturns the compiled `usage` string, with all option descriptions\nand heading/description text, but as markdown instead of\nformatted for a terminal, for generating HTML documentation for\nyour CLI.\n\n## Some Example Code\n\nAlso see [the examples\nfolder](https://github.com/isaacs/jackspeak/tree/master/examples)\n\n```js\nimport { jack } from 'jackspeak'\n\nconst j = jack({\n  // Optional\n  // This will be auto-generated from the descriptions if not supplied\n  // top level usage line, printed by -h\n  // will be auto-generated if not specified\n  usage: 'foo [options] <files>',\n})\n  .heading('The best Foo that ever Fooed')\n  .description(\n    `\n    Executes all the files and interprets their output as\n    TAP formatted test result data.\n\n    To parse TAP data from stdin, specify \"-\" as a filename.\n  `,\n  )\n\n  // flags don't take a value, they're boolean on or off, and can be\n  // turned off by prefixing with `--no-`\n  // so this adds support for -b to mean --bail, or -B to mean --no-bail\n  .flag({\n    flag: {\n      // specify a short value if you like.  this must be a single char\n      short: 'f',\n      // description is optional as well.\n      description: `Make the flags wave`,\n      // default value for flags is 'false', unless you change it\n      default: true,\n    },\n    'no-flag': {\n      // you can can always negate a flag with `--no-flag`\n      // specifying a negate option will let you define a short\n      // single-char option for negation.\n      short: 'F',\n      description: `Do not wave the flags`,\n    },\n  })\n\n  // Options that take a value are specified with `opt()`\n  .opt({\n    reporter: {\n      short: 'R',\n      description: 'the style of report to display',\n    },\n  })\n\n  // if you want a number, say so, and jackspeak will enforce it\n  .num({\n    jobs: {\n      short: 'j',\n      description: 'how many jobs to run in parallel',\n      default: 1,\n    },\n  })\n\n  // A list is an option that can be specified multiple times,\n  // to expand into an array of all the settings.  Normal opts\n  // will just give you the last value specified.\n  .optList({\n    'node-arg': {},\n  })\n\n  // a flagList is an array of booleans, so `-ddd` is [true, true, true]\n  // count the `true` values to treat it as a counter.\n  .flagList({\n    debug: { short: 'd' },\n  })\n\n  // opts take a value, and is set to the string in the results\n  // you can combine multiple short-form flags together, but\n  // an opt will end the combine chain, posix-style.  So,\n  // -bofilename would be like --bail --output-file=filename\n  .opt({\n    'output-file': {\n      short: 'o',\n      // optional: make it -o<file> in the help output insead of -o<value>\n      hint: 'file',\n      description: `Send the raw output to the specified file.`,\n    },\n  })\n\n// now we can parse argv like this:\nconst { values, positionals } = j.parse(process.argv)\n\n// or decide to show the usage banner\nconsole.log(j.usage())\n\n// or validate an object config we got from somewhere else\ntry {\n  j.validate(someConfig)\n} catch (er) {\n  console.error('someConfig is not valid!', er)\n}\n```\n\n## Name\n\nThe inspiration for this module is [yargs](http://npm.im/yargs), which\nis pirate talk themed. Yargs has all the features, and is infinitely\nflexible. \"Jackspeak\" is the slang of the royal navy. This module\ndoes not have all the features. It is declarative and rigid by design.\n","readmeFilename":"README.md"}

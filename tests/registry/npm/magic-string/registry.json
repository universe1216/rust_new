{"name":"magic-string","description":"Modify strings, generate sourcemaps","dist-tags":{"latest":"0.25.9"},"versions":{"0.25.9":{"name":"magic-string","version":"0.25.9","description":"Modify strings, generate sourcemaps","repository":{"type":"git","url":"git+https://github.com/rich-harris/magic-string.git"},"license":"MIT","author":{"name":"Rich Harris"},"main":"dist/magic-string.cjs.js","module":"dist/magic-string.es.js","jsnext:main":"dist/magic-string.es.js","typings":"index.d.ts","scripts":{"build":"rollup -c","changelog":"conventional-changelog -p angular -i CHANGELOG.md -s","format":"prettier --single-quote --print-width 100 --use-tabs --write src/*.js src/**/*.js","lint":"eslint src test","prepare":"npm run build","prepublishOnly":"rm -rf dist && npm test","release":"bumpp -x \"npm run changelog\" --all --commit --tag --push && npm publish","pretest":"npm run lint && npm run build","test":"mocha","watch":"rollup -cw"},"dependencies":{"sourcemap-codec":"^1.4.8"},"devDependencies":{"@rollup/plugin-buble":"^0.21.3","@rollup/plugin-node-resolve":"^13.1.3","@rollup/plugin-replace":"^4.0.0","bumpp":"^7.1.1","conventional-changelog-cli":"^2.2.2","eslint":"^7.32.0","mocha":"^9.2.1","prettier":"^2.5.1","rollup":"^2.69.0","source-map":"^0.6.1","source-map-support":"^0.5.21"},"gitHead":"69336fccbb46e721d58faa5c7a0d0b7ed6ee09d2","bugs":{"url":"https://github.com/rich-harris/magic-string/issues"},"_id":"magic-string@0.25.9","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-RmF0AsMzgt25qzqqLc1+MbHmhdx0ojF2Fvs4XnOqz2ZOBXzzkEwc/dJQZCYHAn7v1jbVOjAZfK8msRn4BxO4VQ==","shasum":"de7f9faf91ef8a1c91d02c2e5314c8277dbcdd1c","tarball":"http://localhost:4260/magic-string/magic-string-0.25.9.tgz","fileCount":10,"unpackedSize":373056,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiIHOYACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq7eg//b6qpgtc+FurMJQRYvhU9BQPkLx+ILEOPzmw5F6pik3p4vZfd\r\nnWm52DYJN60O0LOHqn4/oaccJoN9UgWu8O7XLWSYOJthVFFgpEjEHn/K7tFb\r\ntLSCAfH/z27pUJQMFVCG/I9Cqkm1KiwTtA4vcU0yLo/J3CUHOwzHhViw7Y1o\r\nQUl66CNGNJ1xS0mF/YW7I1MWbxlDAitYZWua+x+t+pZUmIZSim9eL4+QN2Wd\r\nEkZmd7qC8sUMU7jYwYUrjBBsYODyoHA4MT21AoEu2meOGEe799sxlxAB6ahs\r\nuTOKtzID+j9YrBi90nqWggIRBIPAHQKIFS3u6urub921A/Hoi7LYcdV06h9O\r\nwCq7qEi1ECPh8XjO4SNzu54FJxoXGQb1wAHzuVMJP2Wc2FU0SbcYi/zBTiwF\r\nJZNgGG/Z8Qsn8/He2LilwfwR6VZPloONEEcI7xpLufcxAQJdtUJDRgDc1AGg\r\nSPv25CPe4mU19Faojsybsu0xkcTtTAJ2DJeYpCa8SVh89G8FCZkKCDK49x6i\r\niuS3aKdH1TVtaHjVDA1siqRqG4iclwMVRPoLfPLhOAgBJ93sWW8HVtkssHrh\r\no9zASPgva3E5AWw2vkFKQljuK6SAqnIRh1iA+muBAI1GjTzX5EQViJ9c4goe\r\nonQO2QsrVQWLRQO601TqgWHTFJgO2xzQIOc=\r\n=bJY0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDV8jwBjaFd+UCnIJ2mVDguMYVlrR3OXkx6DiSS8W/f8wIgJXOLH/EUy9wYN0a6HdqJ8zH1CfWuDJ9Okiyb9ecS4Js="}]},"directories":{},"_hasShrinkwrap":false}},"readme":"# magic-string\n\n<a href=\"https://travis-ci.org/Rich-Harris/magic-string\">\n  <img src=\"http://img.shields.io/travis/Rich-Harris/magic-string.svg\"\n       alt=\"build status\">\n</a>\n<a href=\"https://npmjs.org/package/magic-string\">\n  <img src=\"https://img.shields.io/npm/v/magic-string.svg\"\n       alt=\"npm version\">\n</a>\n<a href=\"https://github.com/Rich-Harris/magic-string/blob/master/LICENSE.md\">\n  <img src=\"https://img.shields.io/npm/l/magic-string.svg\"\n       alt=\"license\">\n</a>\n\nSuppose you have some source code. You want to make some light modifications to it - replacing a few characters here and there, wrapping it with a header and footer, etc - and ideally you'd like to generate a [source map](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/) at the end of it. You've thought about using something like [recast](https://github.com/benjamn/recast) (which allows you to generate an AST from some JavaScript, manipulate it, and reprint it with a sourcemap without losing your comments and formatting), but it seems like overkill for your needs (or maybe the source code isn't JavaScript).\n\nYour requirements are, frankly, rather niche. But they're requirements that I also have, and for which I made magic-string. It's a small, fast utility for manipulating strings and generating sourcemaps.\n\n## Installation\n\nmagic-string works in both node.js and browser environments. For node, install with npm:\n\n```bash\nnpm i magic-string\n```\n\nTo use in browser, grab the [magic-string.umd.js](https://unpkg.com/magic-string/dist/magic-string.umd.js) file and add it to your page:\n\n```html\n<script src='magic-string.umd.js'></script>\n```\n\n(It also works with various module systems, if you prefer that sort of thing - it has a dependency on [vlq](https://github.com/Rich-Harris/vlq).)\n\n## Usage\n\nThese examples assume you're in node.js, or something similar:\n\n```js\nimport MagicString from 'magic-string';\nimport fs from 'fs'\n\nconst s = new MagicString('problems = 99');\n\ns.overwrite(0, 8, 'answer');\ns.toString(); // 'answer = 99'\n\ns.overwrite(11, 13, '42'); // character indices always refer to the original string\ns.toString(); // 'answer = 42'\n\ns.prepend('var ').append(';'); // most methods are chainable\ns.toString(); // 'var answer = 42;'\n\nconst map = s.generateMap({\n  source: 'source.js',\n  file: 'converted.js.map',\n  includeContent: true\n}); // generates a v3 sourcemap\n\nfs.writeFileSync('converted.js', s.toString());\nfs.writeFileSync('converted.js.map', map.toString());\n```\n\nYou can pass an options argument:\n\n```js\nconst s = new MagicString(someCode, {\n  // both these options will be used if you later\n  // call `bundle.addSource( s )` - see below\n  filename: 'foo.js',\n  indentExclusionRanges: [/*...*/]\n});\n```\n\n## Methods\n\n### s.addSourcemapLocation( index )\n\nAdds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is `false` (see below).\n\n### s.append( content )\n\nAppends the specified content to the end of the string. Returns `this`.\n\n### s.appendLeft( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *ending* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependLeft(...)`.\n\n### s.appendRight( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *starting* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependRight(...)`.\n\n### s.clone()\n\nDoes what you'd expect.\n\n### s.generateDecodedMap( options )\n\nGenerates a sourcemap object with raw mappings in array form, rather than encoded as a string. See `generateMap` documentation below for options details. Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.\n\n### s.generateMap( options )\n\nGenerates a [version 3 sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit). All options are, well, optional:\n\n* `file` - the filename where you plan to write the sourcemap\n* `source` - the filename of the file containing the original source\n* `includeContent` - whether to include the original content in the map's `sourcesContent` array\n* `hires` - whether the mapping should be high-resolution. Hi-res mappings map every single character, meaning (for example) your devtools will always be able to pinpoint the exact location of function calls and so on. With lo-res mappings, devtools may only be able to identify the correct line - but they're quicker to generate and less bulky. If sourcemap locations have been specified with `s.addSourceMapLocation()`, they will be used here.\n\nThe returned sourcemap has two (non-enumerable) methods attached for convenience:\n\n* `toString` - returns the equivalent of `JSON.stringify(map)`\n* `toUrl` - returns a DataURI containing the sourcemap. Useful for doing this sort of thing:\n\n```js\ncode += '\\n//# sourceMappingURL=' + map.toUrl();\n```\n\n### s.hasChanged()\n\nIndicates if the string has been changed.\n\n### s.indent( prefix[, options] )\n\nPrefixes each line of the string with `prefix`. If `prefix` is not supplied, the indentation will be guessed from the original content, falling back to a single tab character. Returns `this`.\n\nThe `options` argument can have an `exclude` property, which is an array of `[start, end]` character ranges. These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.\n\n### s.insertLeft( index, content )\n\n**DEPRECATED** since 0.17 – use `s.appendLeft(...)` instead\n\n### s.insertRight( index, content )\n\n**DEPRECATED** since 0.17 – use `s.prependRight(...)` instead\n\n### s.locate( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.locateOrigin( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.move( start, end, newIndex )\n\nMoves the characters from `start` and `end` to `index`. Returns `this`.\n\n### s.overwrite( start, end, content[, options] )\n\nReplaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply. Returns `this`.\n\nThe fourth argument is optional. It can have a `storeName` property — if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array — and a `contentOnly` property which determines whether only the content is overwritten, or anything that was appended/prepended to the range as well.\n\n### s.prepend( content )\n\nPrepends the string with the specified content. Returns `this`.\n\n### s.prependLeft ( index, content )\n\nSame as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.prependRight ( index, content )\n\nSame as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.replace( regexp, substitution )\n\nString replacement with RegExp or string, a replacer function is also supported. Returns `this`.\n\n```ts\nimport MagicString from 'magic-string'\n\nconst s = new MagicString(source)\n\ns.replace('foo', 'bar')\ns.replace(/foo/g, 'bar')\ns.replace(/(\\w)(\\d+)/g, (_, $1, $2) => $1.toUpperCase() + $2)\n```\n\nThe differences from [`String.replace`]((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)):\n- It will always match against the **original string**\n- It mutates the magic string state (use `.clone()` to be immutable)\n\n### s.remove( start, end )\n\nRemoves the characters from `start` to `end` (of the original string, **not** the generated string). Removing the same content twice, or making removals that partially overlap, will cause an error. Returns `this`.\n\n### s.slice( start, end )\n\nReturns the content of the generated string that corresponds to the slice between `start` and `end` of the original string. Throws error if the indices are for characters that were already removed.\n\n### s.snip( start, end )\n\nReturns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.\n\n### s.toString()\n\nReturns the generated string.\n\n### s.trim([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start and end. Returns `this`.\n\n### s.trimStart([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start. Returns `this`.\n\n### s.trimEnd([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the end. Returns `this`.\n\n### s.trimLines()\n\nRemoves empty lines from the start and end. Returns `this`.\n\n### s.isEmpty()\n\nReturns true if the resulting source is empty (disregarding white space).\n\n## Bundling\n\nTo concatenate several sources, use `MagicString.Bundle`:\n\n```js\nconst bundle = new MagicString.Bundle();\n\nbundle.addSource({\n  filename: 'foo.js',\n  content: new MagicString('var answer = 42;')\n});\n\nbundle.addSource({\n  filename: 'bar.js',\n  content: new MagicString('console.log( answer )')\n});\n\n// Advanced: a source can include an `indentExclusionRanges` property\n// alongside `filename` and `content`. This will be passed to `s.indent()`\n// - see documentation above\n\nbundle.indent() // optionally, pass an indent string, otherwise it will be guessed\n  .prepend('(function () {\\n')\n  .append('}());');\n\nbundle.toString();\n// (function () {\n//   var answer = 42;\n//   console.log( answer );\n// }());\n\n// options are as per `s.generateMap()` above\nconst map = bundle.generateMap({\n  file: 'bundle.js',\n  includeContent: true,\n  hires: true\n});\n```\n\nAs an alternative syntax, if you a) don't have `filename` or `indentExclusionRanges` options, or b) passed those in when you used `new MagicString(...)`, you can simply pass the `MagicString` instance itself:\n\n```js\nconst bundle = new MagicString.Bundle();\nconst source = new MagicString(someCode, {\n  filename: 'foo.js'\n});\n\nbundle.addSource(source);\n```\n\n## License\n\nMIT\n","author":{"name":"Rich Harris"},"license":"MIT","readmeFilename":"README.md","homepage":"https://github.com/rich-harris/magic-string#readme","repository":{"type":"git","url":"git+https://github.com/rich-harris/magic-string.git"},"bugs":{"url":"https://github.com/rich-harris/magic-string/issues"}}

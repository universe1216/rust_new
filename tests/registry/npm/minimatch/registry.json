{"name":"minimatch","dist-tags":{"latest":"9.0.5"},"versions":{"9.0.5":{"name":"minimatch","version":"9.0.5","author":{"url":"http://blog.izs.me","name":"Isaac Z. Schlueter","email":"i@izs.me"},"license":"ISC","_id":"minimatch@9.0.5","bugs":{"url":"https://github.com/isaacs/minimatch/issues"},"dist":{"shasum":"d74f9dd6b57d83d8e98cfb82133b03978bc929e5","tarball":"http://localhost:4260/minimatch/minimatch-9.0.5.tgz","fileCount":53,"integrity":"sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==","signatures":[{"sig":"MEYCIQC8i1XVlxHUOKd0etL7moPA7FuIE5d+E6J4fd1YQj0btgIhAMtyRwTteIb7e0oR/SIFP0LK/JFECg7Aj3KbraAX9pih","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":435003},"main":"./dist/commonjs/index.js","tshy":{"exports":{".":"./src/index.ts","./package.json":"./package.json"}},"type":"module","types":"./dist/commonjs/index.d.ts","engines":{"node":">=16 || 14 >=14.17"},"exports":{".":{"import":{"types":"./dist/esm/index.d.ts","default":"./dist/esm/index.js"},"require":{"types":"./dist/commonjs/index.d.ts","default":"./dist/commonjs/index.js"}},"./package.json":"./package.json"},"funding":{"url":"https://github.com/sponsors/isaacs"},"gitHead":"0de7f45232cad5e3e49e4eb7cd9b6e124ed04b84","scripts":{"snap":"tap","test":"tap","format":"prettier --write . --loglevel warn","prepare":"tshy","presnap":"npm run prepare","pretest":"npm run prepare","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts","benchmark":"node benchmark/index.js","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"prettier":{"semi":false,"useTabs":false,"tabWidth":2,"endOfLine":"lf","printWidth":80,"arrowParens":"avoid","singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true},"repository":{"url":"git://github.com/isaacs/minimatch.git","type":"git"},"_npmVersion":"10.7.0","description":"a glob matcher in javascript","directories":{},"_nodeVersion":"20.13.1","dependencies":{"brace-expansion":"^2.0.1"},"_hasShrinkwrap":false,"devDependencies":{"tap":"^18.7.2","tshy":"^1.12.0","mkdirp":"1","ts-node":"^10.9.1","typedoc":"^0.23.21","prettier":"^2.8.2","@types/tap":"^15.0.8","typescript":"^4.9.3","@types/node":"^18.15.11","@types/brace-expansion":"^1.1.0","eslint-config-prettier":"^8.6.0"}}},"bugs":{"url":"https://github.com/isaacs/minimatch/issues"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me"},"license":"ISC","homepage":"https://github.com/isaacs/minimatch#readme","repository":{"type":"git","url":"git://github.com/isaacs/minimatch.git"},"description":"a glob matcher in javascript","readme":"# minimatch\n\nA minimal matching utility.\n\nThis is the matching library used internally by npm.\n\nIt works by converting glob expressions into JavaScript `RegExp`\nobjects.\n\n## Usage\n\n```js\n// hybrid module, load with require() or import\nimport { minimatch } from 'minimatch'\n// or:\nconst { minimatch } = require('minimatch')\n\nminimatch('bar.foo', '*.foo') // true!\nminimatch('bar.foo', '*.bar') // false!\nminimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!\n```\n\n## Features\n\nSupports these glob features:\n\n- Brace Expansion\n- Extended glob matching\n- \"Globstar\" `**` matching\n- [Posix character\n  classes](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html),\n  like `[[:alpha:]]`, supporting the full range of Unicode\n  characters. For example, `[[:alpha:]]` will match against\n  `'é'`, though `[a-zA-Z]` will not. Collating symbol and set\n  matching is not supported, so `[[=e=]]` will _not_ match `'é'`\n  and `[[.ch.]]` will not match `'ch'` in locales where `ch` is\n  considered a single character.\n\nSee:\n\n- `man sh`\n- `man bash` [Pattern\n  Matching](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html)\n- `man 3 fnmatch`\n- `man 5 gitignore`\n\n## Windows\n\n**Please only use forward-slashes in glob expressions.**\n\nThough windows uses either `/` or `\\` as its path separator, only `/`\ncharacters are used by this glob implementation. You must use\nforward-slashes **only** in glob expressions. Back-slashes in patterns\nwill always be interpreted as escape characters, not path separators.\n\nNote that `\\` or `/` _will_ be interpreted as path separators in paths on\nWindows, and will match against `/` in glob expressions.\n\nSo just always use `/` in patterns.\n\n### UNC Paths\n\nOn Windows, UNC paths like `//?/c:/...` or\n`//ComputerName/Share/...` are handled specially.\n\n- Patterns starting with a double-slash followed by some\n  non-slash characters will preserve their double-slash. As a\n  result, a pattern like `//*` will match `//x`, but not `/x`.\n- Patterns staring with `//?/<drive letter>:` will _not_ treat\n  the `?` as a wildcard character. Instead, it will be treated\n  as a normal string.\n- Patterns starting with `//?/<drive letter>:/...` will match\n  file paths starting with `<drive letter>:/...`, and vice versa,\n  as if the `//?/` was not present. This behavior only is\n  present when the drive letters are a case-insensitive match to\n  one another. The remaining portions of the path/pattern are\n  compared case sensitively, unless `nocase:true` is set.\n\nNote that specifying a UNC path using `\\` characters as path\nseparators is always allowed in the file path argument, but only\nallowed in the pattern argument when `windowsPathsNoEscape: true`\nis set in the options.\n\n## Minimatch Class\n\nCreate a minimatch object by instantiating the `minimatch.Minimatch` class.\n\n```javascript\nvar Minimatch = require('minimatch').Minimatch\nvar mm = new Minimatch(pattern, options)\n```\n\n### Properties\n\n- `pattern` The original pattern the minimatch object represents.\n- `options` The options supplied to the constructor.\n- `set` A 2-dimensional array of regexp or string expressions.\n  Each row in the\n  array corresponds to a brace-expanded pattern. Each item in the row\n  corresponds to a single path-part. For example, the pattern\n  `{a,b/c}/d` would expand to a set of patterns like:\n\n        [ [ a, d ]\n        , [ b, c, d ] ]\n\n  If a portion of the pattern doesn't have any \"magic\" in it\n  (that is, it's something like `\"foo\"` rather than `fo*o?`), then it\n  will be left as a string rather than converted to a regular\n  expression.\n\n- `regexp` Created by the `makeRe` method. A single regular expression\n  expressing the entire pattern. This is useful in cases where you wish\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\n- `negate` True if the pattern is negated.\n- `comment` True if the pattern is a comment.\n- `empty` True if the pattern is `\"\"`.\n\n### Methods\n\n- `makeRe()` Generate the `regexp` member if necessary, and return it.\n  Will return `false` if the pattern is invalid.\n- `match(fname)` Return true if the filename matches the pattern, or\n  false otherwise.\n- `matchOne(fileArray, patternArray, partial)` Take a `/`-split\n  filename, and match it against a single row in the `regExpSet`. This\n  method is mainly for internal use, but is exposed so that it can be\n  used by a glob-walker that needs to avoid excessive filesystem calls.\n- `hasMagic()` Returns true if the parsed pattern contains any\n  magic characters. Returns false if all comparator parts are\n  string literals. If the `magicalBraces` option is set on the\n  constructor, then it will consider brace expansions which are\n  not otherwise magical to be magic. If not set, then a pattern\n  like `a{b,c}d` will return `false`, because neither `abd` nor\n  `acd` contain any special glob characters.\n\n  This does **not** mean that the pattern string can be used as a\n  literal filename, as it may contain magic glob characters that\n  are escaped. For example, the pattern `\\\\*` or `[*]` would not\n  be considered to have magic, as the matching portion parses to\n  the literal string `'*'` and would match a path named `'*'`,\n  not `'\\\\*'` or `'[*]'`. The `minimatch.unescape()` method may\n  be used to remove escape characters.\n\nAll other methods are internal, and will be called as necessary.\n\n### minimatch(path, pattern, options)\n\nMain export. Tests a path against the pattern using the options.\n\n```javascript\nvar isJS = minimatch(file, '*.js', { matchBase: true })\n```\n\n### minimatch.filter(pattern, options)\n\nReturns a function that tests its\nsupplied argument, suitable for use with `Array.filter`. Example:\n\n```javascript\nvar javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))\n```\n\n### minimatch.escape(pattern, options = {})\n\nEscape all magic characters in a glob pattern, so that it will\nonly ever match literal strings\n\nIf the `windowsPathsNoEscape` option is used, then characters are\nescaped by wrapping in `[]`, because a magic character wrapped in\na character class can only be satisfied by that exact character.\n\nSlashes (and backslashes in `windowsPathsNoEscape` mode) cannot\nbe escaped or unescaped.\n\n### minimatch.unescape(pattern, options = {})\n\nUn-escape a glob string that may contain some escaped characters.\n\nIf the `windowsPathsNoEscape` option is used, then square-brace\nescapes are removed, but not backslash escapes. For example, it\nwill turn the string `'[*]'` into `*`, but it will not turn\n`'\\\\*'` into `'*'`, because `\\` is a path separator in\n`windowsPathsNoEscape` mode.\n\nWhen `windowsPathsNoEscape` is not set, then both brace escapes\nand backslash escapes are removed.\n\nSlashes (and backslashes in `windowsPathsNoEscape` mode) cannot\nbe escaped or unescaped.\n\n### minimatch.match(list, pattern, options)\n\nMatch against the list of\nfiles, in the style of fnmatch or glob. If nothing is matched, and\noptions.nonull is set, then return a list containing the pattern itself.\n\n```javascript\nvar javascripts = minimatch.match(fileList, '*.js', { matchBase: true })\n```\n\n### minimatch.makeRe(pattern, options)\n\nMake a regular expression object from the pattern.\n\n## Options\n\nAll options are `false` by default.\n\n### debug\n\nDump a ton of stuff to stderr.\n\n### nobrace\n\nDo not expand `{a,b}` and `{1..3}` brace sets.\n\n### noglobstar\n\nDisable `**` matching against multiple folder names.\n\n### dot\n\nAllow patterns to match filenames starting with a period, even if\nthe pattern does not explicitly have a period in that spot.\n\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\nis set.\n\n### noext\n\nDisable \"extglob\" style patterns like `+(a|b)`.\n\n### nocase\n\nPerform a case-insensitive match.\n\n### nocaseMagicOnly\n\nWhen used with `{nocase: true}`, create regular expressions that\nare case-insensitive, but leave string match portions untouched.\nHas no effect when used without `{nocase: true}`\n\nUseful when some other form of case-insensitive matching is used,\nor if the original string representation is useful in some other\nway.\n\n### nonull\n\nWhen a match is not found by `minimatch.match`, return a list containing\nthe pattern itself if this option is set. When not set, an empty list\nis returned if there are no matches.\n\n### magicalBraces\n\nThis only affects the results of the `Minimatch.hasMagic` method.\n\nIf the pattern contains brace expansions, such as `a{b,c}d`, but\nno other magic characters, then the `Minimatch.hasMagic()` method\nwill return `false` by default. When this option set, it will\nreturn `true` for brace expansion as well as other magic glob\ncharacters.\n\n### matchBase\n\nIf set, then patterns without slashes will be matched\nagainst the basename of the path if it contains slashes. For example,\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\n\n### nocomment\n\nSuppress the behavior of treating `#` at the start of a pattern as a\ncomment.\n\n### nonegate\n\nSuppress the behavior of treating a leading `!` character as negation.\n\n### flipNegate\n\nReturns from negate expressions the same as if they were not negated.\n(Ie, true on a hit, false on a miss.)\n\n### partial\n\nCompare a partial path to a pattern. As long as the parts of the path that\nare present are not contradicted by the pattern, it will be treated as a\nmatch. This is useful in applications where you're walking through a\nfolder structure, and don't yet have the full path, but want to ensure that\nyou do not walk down paths that can never be a match.\n\nFor example,\n\n```js\nminimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d\nminimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d\nminimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a\n```\n\n### windowsPathsNoEscape\n\nUse `\\\\` as a path separator _only_, and _never_ as an escape\ncharacter. If set, all `\\\\` characters are replaced with `/` in\nthe pattern. Note that this makes it **impossible** to match\nagainst paths containing literal glob pattern characters, but\nallows matching with patterns constructed using `path.join()` and\n`path.resolve()` on Windows platforms, mimicking the (buggy!)\nbehavior of earlier versions on Windows. Please use with\ncaution, and be mindful of [the caveat about Windows\npaths](#windows).\n\nFor legacy reasons, this is also set if\n`options.allowWindowsEscape` is set to the exact value `false`.\n\n### windowsNoMagicRoot\n\nWhen a pattern starts with a UNC path or drive letter, and in\n`nocase:true` mode, do not convert the root portions of the\npattern into a case-insensitive regular expression, and instead\nleave them as strings.\n\nThis is the default when the platform is `win32` and\n`nocase:true` is set.\n\n### preserveMultipleSlashes\n\nBy default, multiple `/` characters (other than the leading `//`\nin a UNC path, see \"UNC Paths\" above) are treated as a single\n`/`.\n\nThat is, a pattern like `a///b` will match the file path `a/b`.\n\nSet `preserveMultipleSlashes: true` to suppress this behavior.\n\n### optimizationLevel\n\nA number indicating the level of optimization that should be done\nto the pattern prior to parsing and using it for matches.\n\nGlobstar parts `**` are always converted to `*` when `noglobstar`\nis set, and multiple adjacent `**` parts are converted into a\nsingle `**` (ie, `a/**/**/b` will be treated as `a/**/b`, as this\nis equivalent in all cases).\n\n- `0` - Make no further changes. In this mode, `.` and `..` are\n  maintained in the pattern, meaning that they must also appear\n  in the same position in the test path string. Eg, a pattern\n  like `a/*/../c` will match the string `a/b/../c` but not the\n  string `a/c`.\n- `1` - (default) Remove cases where a double-dot `..` follows a\n  pattern portion that is not `**`, `.`, `..`, or empty `''`. For\n  example, the pattern `./a/b/../*` is converted to `./a/*`, and\n  so it will match the path string `./a/c`, but not the path\n  string `./a/b/../c`. Dots and empty path portions in the\n  pattern are preserved.\n- `2` (or higher) - Much more aggressive optimizations, suitable\n  for use with file-walking cases:\n\n  - Remove cases where a double-dot `..` follows a pattern\n    portion that is not `**`, `.`, or empty `''`. Remove empty\n    and `.` portions of the pattern, where safe to do so (ie,\n    anywhere other than the last position, the first position, or\n    the second position in a pattern starting with `/`, as this\n    may indicate a UNC path on Windows).\n  - Convert patterns containing `<pre>/**/../<p>/<rest>` into the\n    equivalent `<pre>/{..,**}/<p>/<rest>`, where `<p>` is a\n    a pattern portion other than `.`, `..`, `**`, or empty\n    `''`.\n  - Dedupe patterns where a `**` portion is present in one and\n    omitted in another, and it is not the final path portion, and\n    they are otherwise equivalent. So `{a/**/b,a/b}` becomes\n    `a/**/b`, because `**` matches against an empty path portion.\n  - Dedupe patterns where a `*` portion is present in one, and a\n    non-dot pattern other than `**`, `.`, `..`, or `''` is in the\n    same position in the other. So `a/{*,x}/b` becomes `a/*/b`,\n    because `*` can match against `x`.\n\n  While these optimizations improve the performance of\n  file-walking use cases such as [glob](http://npm.im/glob) (ie,\n  the reason this module exists), there are cases where it will\n  fail to match a literal string that would have been matched in\n  optimization level 1 or 0.\n\n  Specifically, while the `Minimatch.match()` method will\n  optimize the file path string in the same ways, resulting in\n  the same matches, it will fail when tested with the regular\n  expression provided by `Minimatch.makeRe()`, unless the path\n  string is first processed with\n  `minimatch.levelTwoFileOptimize()` or similar.\n\n### platform\n\nWhen set to `win32`, this will trigger all windows-specific\nbehaviors (special handling for UNC paths, and treating `\\` as\nseparators in file paths for comparison.)\n\nDefaults to the value of `process.platform`.\n\n## Comparisons to other fnmatch/glob implementations\n\nWhile strict compliance with the existing standards is a\nworthwhile goal, some discrepancies exist between minimatch and\nother implementations. Some are intentional, and some are\nunavoidable.\n\nIf the pattern starts with a `!` character, then it is negated. Set the\n`nonegate` flag to suppress this behavior, and treat leading `!`\ncharacters normally. This is perhaps relevant if you wish to start the\npattern with a negative extglob pattern like `!(a|B)`. Multiple `!`\ncharacters at the start of a pattern will negate the pattern multiple\ntimes.\n\nIf a pattern starts with `#`, then it is treated as a comment, and\nwill not match anything. Use `\\#` to match a literal `#` at the\nstart of a line, or set the `nocomment` flag to suppress this behavior.\n\nThe double-star character `**` is supported by default, unless the\n`noglobstar` flag is set. This is supported in the manner of bsdglob\nand bash 4.1, where `**` only has special significance if it is the only\nthing in a path part. That is, `a/**/b` will match `a/x/y/b`, but\n`a/**b` will not.\n\nIf an escaped pattern has no matches, and the `nonull` flag is set,\nthen minimatch.match returns the pattern as-provided, rather than\ninterpreting the character escapes. For example,\n`minimatch.match([], \"\\\\*a\\\\?\")` will return `\"\\\\*a\\\\?\"` rather than\n`\"*a?\"`. This is akin to setting the `nullglob` option in bash, except\nthat it does not resolve escaped pattern characters.\n\nIf brace expansion is not disabled, then it is performed before any\nother interpretation of the glob pattern. Thus, a pattern like\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\nchecked for validity. Since those two are valid, matching proceeds.\n\nNegated extglob patterns are handled as closely as possible to\nBash semantics, but there are some cases with negative extglobs\nwhich are exceedingly difficult to express in a JavaScript\nregular expression. In particular the negated pattern\n`<start>!(<pattern>*|)*` will in bash match anything that does\nnot start with `<start><pattern>`. However,\n`<start>!(<pattern>*)*` _will_ match paths starting with\n`<start><pattern>`, because the empty string can match against\nthe negated portion. In this library, `<start>!(<pattern>*|)*`\nwill _not_ match any pattern starting with `<start>`, due to a\ndifference in precisely which patterns are considered \"greedy\" in\nRegular Expressions vs bash path expansion. This may be fixable,\nbut not without incurring some complexity and performance costs,\nand the trade-off seems to not be worth pursuing.\n\nNote that `fnmatch(3)` in libc is an extremely naive string comparison\nmatcher, which does not do anything special for slashes. This library is\ndesigned to be used in glob searching and file walkers, and so it does do\nspecial things with `/`. Thus, `foo*` will not match `foo/bar` in this\nlibrary, even though it would in `fnmatch(3)`.\n","readmeFilename":"README.md"}

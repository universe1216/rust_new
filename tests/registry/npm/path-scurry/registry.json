{"name":"path-scurry","dist-tags":{"latest":"1.11.1"},"versions":{"1.11.1":{"name":"path-scurry","version":"1.11.1","author":{"url":"https://blog.izs.me","name":"Isaac Z. Schlueter","email":"i@izs.me"},"license":"BlueOak-1.0.0","_id":"path-scurry@1.11.1","bugs":{"url":"https://github.com/isaacs/path-scurry/issues"},"tap":{"typecheck":true},"dist":{"shasum":"7960a668888594a0720b12a911d1a742ab9f11d2","tarball":"http://localhost:4260/path-scurry/path-scurry-1.11.1.tgz","fileCount":13,"integrity":"sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==","signatures":[{"sig":"MEYCIQDBjLbfo2sQti3sfRnzaiinq/kkXl1m+QvSVxxwW4e8xAIhAOU7wQ5HNxGrEROeHVnPM5T/4hhZllwlkzv1Aufgubk8","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":535479},"main":"./dist/commonjs/index.js","tshy":{"exports":{".":"./src/index.ts","./package.json":"./package.json"},"selfLink":false},"type":"module","types":"./dist/commonjs/index.d.ts","engines":{"node":">=16 || 14 >=14.18"},"exports":{".":{"import":{"types":"./dist/esm/index.d.ts","default":"./dist/esm/index.js"},"require":{"types":"./dist/commonjs/index.d.ts","default":"./dist/commonjs/index.js"}},"./package.json":"./package.json"},"funding":{"url":"https://github.com/sponsors/isaacs"},"gitHead":"766c9b06aacef86b43c9999cabc5eb824b5958d6","scripts":{"snap":"tap","test":"tap","bench":"bash ./scripts/bench.sh","format":"prettier --write . --loglevel warn","prepare":"tshy","presnap":"npm run prepare","pretest":"npm run prepare","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"prettier":{"semi":false,"useTabs":false,"tabWidth":2,"endOfLine":"lf","printWidth":75,"arrowParens":"avoid","singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"experimentalTernaries":true},"repository":{"url":"git+https://github.com/isaacs/path-scurry.git","type":"git"},"_npmVersion":"10.7.0","description":"walk paths fast and efficiently","directories":{},"_nodeVersion":"20.11.0","dependencies":{"minipass":"^5.0.0 || ^6.0.2 || ^7.0.0","lru-cache":"^10.2.0"},"_hasShrinkwrap":false,"devDependencies":{"c8":"^7.12.0","tap":"^18.7.2","tshy":"^1.14.0","mkdirp":"^3.0.0","rimraf":"^5.0.1","ts-node":"^10.9.2","typedoc":"^0.25.12","prettier":"^3.2.5","typescript":"^5.4.3","@types/node":"^20.12.11","@nodelib/fs.walk":"^1.2.8","eslint-config-prettier":"^8.6.0"}}},"bugs":{"url":"https://github.com/isaacs/path-scurry/issues"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"https://blog.izs.me"},"license":"BlueOak-1.0.0","homepage":"https://github.com/isaacs/path-scurry#readme","repository":{"type":"git","url":"git+https://github.com/isaacs/path-scurry.git"},"description":"walk paths fast and efficiently","readme":"# path-scurry\n\nExtremely high performant utility for building tools that read\nthe file system, minimizing filesystem and path string munging\noperations to the greatest degree possible.\n\n## Ugh, yet another file traversal thing on npm?\n\nYes. None of the existing ones gave me exactly what I wanted.\n\n## Well what is it you wanted?\n\nWhile working on [glob](http://npm.im/glob), I found that I\nneeded a module to very efficiently manage the traversal over a\nfolder tree, such that:\n\n1. No `readdir()` or `stat()` would ever be called on the same\n   file or directory more than one time.\n2. No `readdir()` calls would be made if we can be reasonably\n   sure that the path is not a directory. (Ie, a previous\n   `readdir()` or `stat()` covered the path, and\n   `ent.isDirectory()` is false.)\n3. `path.resolve()`, `dirname()`, `basename()`, and other\n   string-parsing/munging operations are be minimized. This means\n   it has to track \"provisional\" child nodes that may not exist\n   (and if we find that they _don't_ exist, store that\n   information as well, so we don't have to ever check again).\n4. The API is not limited to use as a stream/iterator/etc. There\n   are many cases where an API like node's `fs` is preferrable.\n5. It's more important to prevent excess syscalls than to be up\n   to date, but it should be smart enough to know what it\n   _doesn't_ know, and go get it seamlessly when requested.\n6. Do not blow up the JS heap allocation if operating on a\n   directory with a huge number of entries.\n7. Handle all the weird aspects of Windows paths, like UNC paths\n   and drive letters and wrongway slashes, so that the consumer\n   can return canonical platform-specific paths without having to\n   parse or join or do any error-prone string munging.\n\n## PERFORMANCE\n\nJavaScript people throw around the word \"blazing\" a lot. I hope\nthat this module doesn't blaze anyone. But it does go very fast,\nin the cases it's optimized for, if used properly.\n\nPathScurry provides ample opportunities to get extremely good\nperformance, as well as several options to trade performance for\nconvenience.\n\nBenchmarks can be run by executing `npm run bench`.\n\nAs is always the case, doing more means going slower, doing less\nmeans going faster, and there are trade offs between speed and\nmemory usage.\n\nPathScurry makes heavy use of [LRUCache](http://npm.im/lru-cache)\nto efficiently cache whatever it can, and `Path` objects remain\nin the graph for the lifetime of the walker, so repeated calls\nwith a single PathScurry object will be extremely fast. However,\nadding items to a cold cache means \"doing more\", so in those\ncases, we pay a price. Nothing is free, but every effort has been\nmade to reduce costs wherever possible.\n\nAlso, note that a \"cache as long as possible\" approach means that\nchanges to the filesystem may not be reflected in the results of\nrepeated PathScurry operations.\n\nFor resolving string paths, `PathScurry` ranges from 5-50 times\nfaster than `path.resolve` on repeated resolutions, but around\n100 to 1000 times _slower_ on the first resolution. If your\nprogram is spending a lot of time resolving the _same_ paths\nrepeatedly (like, thousands or millions of times), then this can\nbe beneficial. But both implementations are pretty fast, and\nspeeding up an infrequent operation from 4Âµs to 400ns is not\ngoing to move the needle on your app's performance.\n\nFor walking file system directory trees, a lot depends on how\noften a given PathScurry object will be used, and also on the\nwalk method used.\n\nWith default settings on a folder tree of 100,000 items,\nconsisting of around a 10-to-1 ratio of normal files to\ndirectories, PathScurry performs comparably to\n[@nodelib/fs.walk](http://npm.im/@nodelib/fs.walk), which is the\nfastest and most reliable file system walker I could find. As far\nas I can tell, it's almost impossible to go much faster in a\nNode.js program, just based on how fast you can push syscalls out\nto the fs thread pool.\n\nOn my machine, that is about 1000-1200 completed walks per second\nfor async or stream walks, and around 500-600 walks per second\nsynchronously.\n\nIn the warm cache state, PathScurry's performance increases\naround 4x for async `for await` iteration, 10-15x faster for\nstreams and synchronous `for of` iteration, and anywhere from 30x\nto 80x faster for the rest.\n\n```\n# walk 100,000 fs entries, 10/1 file/dir ratio\n# operations / ms\n New PathScurry object  |  Reuse PathScurry object\n     stream:  1112.589  |  13974.917\nsync stream:   492.718  |  15028.343\n async walk:  1095.648  |  32706.395\n  sync walk:   527.632  |  46129.772\n async iter:  1288.821  |   5045.510\n  sync iter:   498.496  |  17920.746\n```\n\nA hand-rolled walk calling `entry.readdir()` and recursing\nthrough the entries can benefit even more from caching, with\ngreater flexibility and without the overhead of streams or\ngenerators.\n\nThe cold cache state is still limited by the costs of file system\noperations, but with a warm cache, the only bottleneck is CPU\nspeed and VM optimizations. Of course, in that case, some care\nmust be taken to ensure that you don't lose performance as a\nresult of silly mistakes, like calling `readdir()` on entries\nthat you know are not directories.\n\n```\n# manual recursive iteration functions\n      cold cache  |  warm cache\nasync:  1164.901  |  17923.320\n   cb:  1101.127  |  40999.344\nzalgo:  1082.240  |  66689.936\n sync:   526.935  |  87097.591\n```\n\nIn this case, the speed improves by around 10-20x in the async\ncase, 40x in the case of using `entry.readdirCB` with protections\nagainst synchronous callbacks, and 50-100x with callback\ndeferrals disabled, and _several hundred times faster_ for\nsynchronous iteration.\n\nIf you can think of a case that is not covered in these\nbenchmarks, or an implementation that performs significantly\nbetter than PathScurry, please [let me\nknow](https://github.com/isaacs/path-scurry/issues).\n\n## USAGE\n\n```ts\n// hybrid module, load with either method\nimport { PathScurry, Path } from 'path-scurry'\n// or:\nconst { PathScurry, Path } = require('path-scurry')\n\n// very simple example, say we want to find and\n// delete all the .DS_Store files in a given path\n// note that the API is very similar to just a\n// naive walk with fs.readdir()\nimport { unlink } from 'fs/promises'\n\n// easy way, iterate over the directory and do the thing\nconst pw = new PathScurry(process.cwd())\nfor await (const entry of pw) {\n  if (entry.isFile() && entry.name === '.DS_Store') {\n    unlink(entry.fullpath())\n  }\n}\n\n// here it is as a manual recursive method\nconst walk = async (entry: Path) => {\n  const promises: Promise<any> = []\n  // readdir doesn't throw on non-directories, it just doesn't\n  // return any entries, to save stack trace costs.\n  // Items are returned in arbitrary unsorted order\n  for (const child of await pw.readdir(entry)) {\n    // each child is a Path object\n    if (child.name === '.DS_Store' && child.isFile()) {\n      // could also do pw.resolve(entry, child.name),\n      // just like fs.readdir walking, but .fullpath is\n      // a *slightly* more efficient shorthand.\n      promises.push(unlink(child.fullpath()))\n    } else if (child.isDirectory()) {\n      promises.push(walk(child))\n    }\n  }\n  return Promise.all(promises)\n}\n\nwalk(pw.cwd).then(() => {\n  console.log('all .DS_Store files removed')\n})\n\nconst pw2 = new PathScurry('/a/b/c') // pw2.cwd is the Path for /a/b/c\nconst relativeDir = pw2.cwd.resolve('../x') // Path entry for '/a/b/x'\nconst relative2 = pw2.cwd.resolve('/a/b/d/../x') // same path, same entry\nassert.equal(relativeDir, relative2)\n```\n\n## API\n\n[Full TypeDoc API](https://isaacs.github.io/path-scurry)\n\nThere are platform-specific classes exported, but for the most\npart, the default `PathScurry` and `Path` exports are what you\nmost likely need, unless you are testing behavior for other\nplatforms.\n\nIntended public API is documented here, but the full\ndocumentation does include internal types, which should not be\naccessed directly.\n\n### Interface `PathScurryOpts`\n\nThe type of the `options` argument passed to the `PathScurry`\nconstructor.\n\n- `nocase`: Boolean indicating that file names should be compared\n  case-insensitively. Defaults to `true` on darwin and win32\n  implementations, `false` elsewhere.\n\n  **Warning** Performing case-insensitive matching on a\n  case-sensitive filesystem will result in occasionally very\n  bizarre behavior. Performing case-sensitive matching on a\n  case-insensitive filesystem may negatively impact performance.\n\n- `childrenCacheSize`: Number of child entries to cache, in order\n  to speed up `resolve()` and `readdir()` calls. Defaults to\n  `16 * 1024` (ie, `16384`).\n\n  Setting it to a higher value will run the risk of JS heap\n  allocation errors on large directory trees. Setting it to `256`\n  or smaller will significantly reduce the construction time and\n  data consumption overhead, but with the downside of operations\n  being slower on large directory trees. Setting it to `0` will\n  mean that effectively no operations are cached, and this module\n  will be roughly the same speed as `fs` for file system\n  operations, and _much_ slower than `path.resolve()` for\n  repeated path resolution.\n\n- `fs` An object that will be used to override the default `fs`\n  methods. Any methods that are not overridden will use Node's\n  built-in implementations.\n\n  - lstatSync\n  - readdir (callback `withFileTypes` Dirent variant, used for\n    readdirCB and most walks)\n  - readdirSync\n  - readlinkSync\n  - realpathSync\n  - promises: Object containing the following async methods:\n    - lstat\n    - readdir (Dirent variant only)\n    - readlink\n    - realpath\n\n### Interface `WalkOptions`\n\nThe options object that may be passed to all walk methods.\n\n- `withFileTypes`: Boolean, default true. Indicates that `Path`\n  objects should be returned. Set to `false` to get string paths\n  instead.\n- `follow`: Boolean, default false. Attempt to read directory\n  entries from symbolic links. Otherwise, only actual directories\n  are traversed. Regardless of this setting, a given target path\n  will only ever be walked once, meaning that a symbolic link to\n  a previously traversed directory will never be followed.\n\n  Setting this imposes a slight performance penalty, because\n  `readlink` must be called on all symbolic links encountered, in\n  order to avoid infinite cycles.\n\n- `filter`: Function `(entry: Path) => boolean`. If provided,\n  will prevent the inclusion of any entry for which it returns a\n  falsey value. This will not prevent directories from being\n  traversed if they do not pass the filter, though it will\n  prevent the directories themselves from being included in the\n  results. By default, if no filter is provided, then all entries\n  are included in the results.\n- `walkFilter`: Function `(entry: Path) => boolean`. If provided,\n  will prevent the traversal of any directory (or in the case of\n  `follow:true` symbolic links to directories) for which the\n  function returns false. This will not prevent the directories\n  themselves from being included in the result set. Use `filter`\n  for that.\n\nNote that TypeScript return types will only be inferred properly\nfrom static analysis if the `withFileTypes` option is omitted, or\na constant `true` or `false` value.\n\n### Class `PathScurry`\n\nThe main interface. Defaults to an appropriate class based on the\ncurrent platform.\n\nUse `PathScurryWin32`, `PathScurryDarwin`, or `PathScurryPosix`\nif implementation-specific behavior is desired.\n\nAll walk methods may be called with a `WalkOptions` argument to\nwalk over the object's current working directory with the\nsupplied options.\n\n#### `async pw.walk(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nWalk the directory tree according to the options provided,\nresolving to an array of all entries found.\n\n#### `pw.walkSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nWalk the directory tree according to the options provided,\nreturning an array of all entries found.\n\n#### `pw.iterate(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nIterate over the directory asynchronously, for use with `for\nawait of`. This is also the default async iterator method.\n\n#### `pw.iterateSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nIterate over the directory synchronously, for use with `for of`.\nThis is also the default sync iterator method.\n\n#### `pw.stream(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nReturn a [Minipass](http://npm.im/minipass) stream that emits\neach entry or path string in the walk. Results are made available\nasynchronously.\n\n#### `pw.streamSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)`\n\nReturn a [Minipass](http://npm.im/minipass) stream that emits\neach entry or path string in the walk. Results are made available\nsynchronously, meaning that the walk will complete in a single\ntick if the stream is fully consumed.\n\n#### `pw.cwd`\n\nPath object representing the current working directory for the\nPathScurry.\n\n#### `pw.chdir(path: string)`\n\nSet the new effective current working directory for the scurry\nobject, so that `path.relative()` and `path.relativePosix()`\nreturn values relative to the new cwd path.\n\n#### `pw.depth(path?: Path | string): number`\n\nReturn the depth of the specified path (or the PathScurry cwd)\nwithin the directory tree.\n\nRoot entries have a depth of `0`.\n\n#### `pw.resolve(...paths: string[])`\n\nCaching `path.resolve()`.\n\nSignificantly faster than `path.resolve()` if called repeatedly\nwith the same paths. Significantly slower otherwise, as it builds\nout the cached Path entries.\n\nTo get a `Path` object resolved from the `PathScurry`, use\n`pw.cwd.resolve(path)`. Note that `Path.resolve` only takes a\nsingle string argument, not multiple.\n\n#### `pw.resolvePosix(...paths: string[])`\n\nCaching `path.resolve()`, but always using posix style paths.\n\nThis is identical to `pw.resolve(...paths)` on posix systems (ie,\neverywhere except Windows).\n\nOn Windows, it returns the full absolute UNC path using `/`\nseparators. Ie, instead of `'C:\\\\foo\\\\bar`, it would return\n`//?/C:/foo/bar`.\n\n#### `pw.relative(path: string | Path): string`\n\nReturn the relative path from the PathWalker cwd to the supplied\npath string or entry.\n\nIf the nearest common ancestor is the root, then an absolute path\nis returned.\n\n#### `pw.relativePosix(path: string | Path): string`\n\nReturn the relative path from the PathWalker cwd to the supplied\npath string or entry, using `/` path separators.\n\nIf the nearest common ancestor is the root, then an absolute path\nis returned.\n\nOn posix platforms (ie, all platforms except Windows), this is\nidentical to `pw.relative(path)`.\n\nOn Windows systems, it returns the resulting string as a\n`/`-delimited path. If an absolute path is returned (because the\ntarget does not share a common ancestor with `pw.cwd`), then a\nfull absolute UNC path will be returned. Ie, instead of\n`'C:\\\\foo\\\\bar`, it would return `//?/C:/foo/bar`.\n\n#### `pw.basename(path: string | Path): string`\n\nReturn the basename of the provided string or Path.\n\n#### `pw.dirname(path: string | Path): string`\n\nReturn the parent directory of the supplied string or Path.\n\n#### `async pw.readdir(dir = pw.cwd, opts = { withFileTypes: true })`\n\nRead the directory and resolve to an array of strings if\n`withFileTypes` is explicitly set to `false` or Path objects\notherwise.\n\nCan be called as `pw.readdir({ withFileTypes: boolean })` as\nwell.\n\nReturns `[]` if no entries are found, or if any error occurs.\n\nNote that TypeScript return types will only be inferred properly\nfrom static analysis if the `withFileTypes` option is omitted, or\na constant `true` or `false` value.\n\n#### `pw.readdirSync(dir = pw.cwd, opts = { withFileTypes: true })`\n\nSynchronous `pw.readdir()`\n\n#### `async pw.readlink(link = pw.cwd, opts = { withFileTypes: false })`\n\nCall `fs.readlink` on the supplied string or Path object, and\nreturn the result.\n\nCan be called as `pw.readlink({ withFileTypes: boolean })` as\nwell.\n\nReturns `undefined` if any error occurs (for example, if the\nargument is not a symbolic link), or a `Path` object if\n`withFileTypes` is explicitly set to `true`, or a string\notherwise.\n\nNote that TypeScript return types will only be inferred properly\nfrom static analysis if the `withFileTypes` option is omitted, or\na constant `true` or `false` value.\n\n#### `pw.readlinkSync(link = pw.cwd, opts = { withFileTypes: false })`\n\nSynchronous `pw.readlink()`\n\n#### `async pw.lstat(entry = pw.cwd)`\n\nCall `fs.lstat` on the supplied string or Path object, and fill\nin as much information as possible, returning the updated `Path`\nobject.\n\nReturns `undefined` if the entry does not exist, or if any error\nis encountered.\n\nNote that some `Stats` data (such as `ino`, `dev`, and `mode`)\nwill not be supplied. For those things, you'll need to call\n`fs.lstat` yourself.\n\n#### `pw.lstatSync(entry = pw.cwd)`\n\nSynchronous `pw.lstat()`\n\n#### `pw.realpath(entry = pw.cwd, opts = { withFileTypes: false })`\n\nCall `fs.realpath` on the supplied string or Path object, and\nreturn the realpath if available.\n\nReturns `undefined` if any error occurs.\n\nMay be called as `pw.realpath({ withFileTypes: boolean })` to run\non `pw.cwd`.\n\n#### `pw.realpathSync(entry = pw.cwd, opts = { withFileTypes: false })`\n\nSynchronous `pw.realpath()`\n\n### Class `Path` implements [fs.Dirent](https://nodejs.org/docs/latest/api/fs.html#class-fsdirent)\n\nObject representing a given path on the filesystem, which may or\nmay not exist.\n\nNote that the actual class in use will be either `PathWin32` or\n`PathPosix`, depending on the implementation of `PathScurry` in\nuse. They differ in the separators used to split and join path\nstrings, and the handling of root paths.\n\nIn `PathPosix` implementations, paths are split and joined using\nthe `'/'` character, and `'/'` is the only root path ever in use.\n\nIn `PathWin32` implementations, paths are split using either\n`'/'` or `'\\\\'` and joined using `'\\\\'`, and multiple roots may\nbe in use based on the drives and UNC paths encountered. UNC\npaths such as `//?/C:/` that identify a drive letter, will be\ntreated as an alias for the same root entry as their associated\ndrive letter (in this case `'C:\\\\'`).\n\n#### `path.name`\n\nName of this file system entry.\n\n**Important**: _always_ test the path name against any test\nstring using the `isNamed` method, and not by directly comparing\nthis string. Otherwise, unicode path strings that the system sees\nas identical will not be properly treated as the same path,\nleading to incorrect behavior and possible security issues.\n\n#### `path.isNamed(name: string): boolean`\n\nReturn true if the path is a match for the given path name. This\nhandles case sensitivity and unicode normalization.\n\nNote: even on case-sensitive systems, it is **not** safe to test\nthe equality of the `.name` property to determine whether a given\npathname matches, due to unicode normalization mismatches.\n\nAlways use this method instead of testing the `path.name`\nproperty directly.\n\n#### `path.isCWD`\n\nSet to true if this `Path` object is the current working\ndirectory of the `PathScurry` collection that contains it.\n\n#### `path.getType()`\n\nReturns the type of the Path object, `'File'`, `'Directory'`,\netc.\n\n#### `path.isType(t: type)`\n\nReturns true if `is{t}()` returns true.\n\nFor example, `path.isType('Directory')` is equivalent to\n`path.isDirectory()`.\n\n#### `path.depth()`\n\nReturn the depth of the Path entry within the directory tree.\nRoot paths have a depth of `0`.\n\n#### `path.fullpath()`\n\nThe fully resolved path to the entry.\n\n#### `path.fullpathPosix()`\n\nThe fully resolved path to the entry, using `/` separators.\n\nOn posix systems, this is identical to `path.fullpath()`. On\nwindows, this will return a fully resolved absolute UNC path\nusing `/` separators. Eg, instead of `'C:\\\\foo\\\\bar'`, it will\nreturn `'//?/C:/foo/bar'`.\n\n#### `path.isFile()`, `path.isDirectory()`, etc.\n\nSame as the identical `fs.Dirent.isX()` methods.\n\n#### `path.isUnknown()`\n\nReturns true if the path's type is unknown. Always returns true\nwhen the path is known to not exist.\n\n#### `path.resolve(p: string)`\n\nReturn a `Path` object associated with the provided path string\nas resolved from the current Path object.\n\n#### `path.relative(): string`\n\nReturn the relative path from the PathWalker cwd to the supplied\npath string or entry.\n\nIf the nearest common ancestor is the root, then an absolute path\nis returned.\n\n#### `path.relativePosix(): string`\n\nReturn the relative path from the PathWalker cwd to the supplied\npath string or entry, using `/` path separators.\n\nIf the nearest common ancestor is the root, then an absolute path\nis returned.\n\nOn posix platforms (ie, all platforms except Windows), this is\nidentical to `pw.relative(path)`.\n\nOn Windows systems, it returns the resulting string as a\n`/`-delimited path. If an absolute path is returned (because the\ntarget does not share a common ancestor with `pw.cwd`), then a\nfull absolute UNC path will be returned. Ie, instead of\n`'C:\\\\foo\\\\bar`, it would return `//?/C:/foo/bar`.\n\n#### `async path.readdir()`\n\nReturn an array of `Path` objects found by reading the associated\npath entry.\n\nIf path is not a directory, or if any error occurs, returns `[]`,\nand marks all children as provisional and non-existent.\n\n#### `path.readdirSync()`\n\nSynchronous `path.readdir()`\n\n#### `async path.readlink()`\n\nReturn the `Path` object referenced by the `path` as a symbolic\nlink.\n\nIf the `path` is not a symbolic link, or any error occurs,\nreturns `undefined`.\n\n#### `path.readlinkSync()`\n\nSynchronous `path.readlink()`\n\n#### `async path.lstat()`\n\nCall `lstat` on the path object, and fill it in with details\ndetermined.\n\nIf path does not exist, or any other error occurs, returns\n`undefined`, and marks the path as \"unknown\" type.\n\n#### `path.lstatSync()`\n\nSynchronous `path.lstat()`\n\n#### `async path.realpath()`\n\nCall `realpath` on the path, and return a Path object\ncorresponding to the result, or `undefined` if any error occurs.\n\n#### `path.realpathSync()`\n\nSynchornous `path.realpath()`\n","readmeFilename":"README.md"}
